#!/usr/bin/env python3
"""
Blackbox Log Parser for R2W Robot

Parses DUMP_*.BIN files generated by the STM32H723 blackbox flight recorder.
Extracts telemetry data, validates CRCs, and exports to CSV or plots.

File Format:
    - LogMeta (52 bytes): Metadata header
    - LogRecord[N] (160 bytes each): Telemetry records
    - LogDumpTrailer (16 bytes): Trailer with sequence numbers

Usage:
    python parse_blackbox.py DUMP_0001.BIN --csv output.csv
    python parse_blackbox.py DUMP_0001.BIN --plot
    python parse_blackbox.py DUMP_0001.BIN --info
"""

import argparse
import struct
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional
import zlib


# Constants from blackbox_format.h
LOG_RECORD_MAGIC = 0xA55A
LOG_RECORD_VERSION = 1
LOG_RECORD_SIZE = 160

LOG_META_MAGIC = b"R2WLOG1\0"
LOG_META_VERSION = 1
LOG_META_FORMAT = '<8sHHHIHIIIIIIII'
LOG_META_SIZE = struct.calcsize(LOG_META_FORMAT)
LOG_RECORD_MIN_SIZE = struct.calcsize('<HBBIIB3x3h3h3f5f3f9fI')
LOG_RECORD_MAGIC_BYTES = struct.pack('<H', LOG_RECORD_MAGIC)
MAX_RECORD_START_SEARCH = 4096

# Field bitmasks
LOGF_IMU_RAW = 1 << 0
LOGF_IMU2_HEALTH = 1 << 1
LOGF_EKF = 1 << 2
LOGF_WHEELS = 1 << 3
LOGF_PID = 1 << 4

# Record flags
LOGF_REC_ACCEL_GATED = 1 << 0
LOGF_REC_IMU_FALLBACK = 1 << 1
LOGF_REC_UL_SAT = 1 << 2
LOGF_REC_UR_SAT = 1 << 3
LOGF_REC_FALLEN = 1 << 4
LOGF_REC_ARMED = 1 << 5


@dataclass
class LogMeta:
    """Log metadata structure (52 bytes)"""
    magic: bytes  # 8 bytes
    version: int  # uint16
    record_size: int  # uint16
    rate_hz: int  # uint16
    log_fields_mask: int  # uint32
    reserved: int  # uint16
    ring_start: int  # uint32
    ring_size: int  # uint32
    write_addr: int  # uint32
    wrap_count: int  # uint32
    boot_count: int  # uint32
    last_dump_id: int  # uint32
    sequence: int  # uint32
    meta_crc32: int  # uint32

    @classmethod
    def from_bytes(cls, data: bytes) -> 'LogMeta':
        """Parse LogMeta from binary data"""
        if len(data) < LOG_META_SIZE:
            raise ValueError(f"LogMeta data too short: {len(data)} bytes")

        # Unpack structure: 8s H H H I H I I I I I I I I
        values = struct.unpack(LOG_META_FORMAT, data[:LOG_META_SIZE])
        return cls(*values)

    def validate(self) -> bool:
        """Validate metadata magic and CRC"""
        if self.magic != LOG_META_MAGIC:
            return False

        # Recompute CRC (all fields except last 4 bytes)
        data = struct.pack('<8sHHHIHIIIIIII',
                          self.magic, self.version, self.record_size,
                          self.rate_hz, self.log_fields_mask, self.reserved,
                          self.ring_start, self.ring_size, self.write_addr,
                          self.wrap_count, self.boot_count, self.last_dump_id,
                          self.sequence)
        computed_crc = zlib.crc32(data) & 0xFFFFFFFF
        return computed_crc == self.meta_crc32


@dataclass
class LogRecord:
    """Log record structure (160 bytes)"""
    # Header
    magic: int  # uint16
    version: int  # uint8
    flags: int  # uint8
    seq: int  # uint32
    t_us: int  # uint32
    active_imu: int  # uint8

    # IMU raw data (LOGF_IMU_RAW)
    acc_raw: tuple  # int16[3]
    gyro_raw: tuple  # int16[3]

    # Dual-IMU health (LOGF_IMU2_HEALTH)
    gyro_diff_dps: float
    acc_angle_deg: float
    vib_grms: float

    # EKF state (LOGF_EKF)
    theta_rad: float
    thetaDot_rads: float
    gyro_bias_rads: float
    x_m: float
    x_dot_mps: float

    # Wheels (LOGF_WHEELS)
    wL_rads: float
    wR_rads: float
    v_mps: float

    # PID (LOGF_PID)
    theta_ref_rad: float
    e_theta_rad: float
    P: float
    I: float
    D: float
    u_common: float
    u_turn: float
    uL_cmd: float
    uR_cmd: float

    # Trailer
    crc32: int  # uint32

    @classmethod
    def from_bytes(cls, data: bytes) -> 'LogRecord':
        """Parse LogRecord from binary data"""
        if len(data) < LOG_RECORD_MIN_SIZE:
            raise ValueError(f"LogRecord data too short: {len(data)} bytes")

        # Unpack header: H B B I I B 3x
        header_fmt = '<HBBIIB3x'
        header_size = struct.calcsize(header_fmt)
        magic, version, flags, seq, t_us, active_imu = struct.unpack(
            header_fmt, data[:header_size])

        offset = header_size

        # IMU raw: 6 int16 = 12 bytes
        acc_raw = struct.unpack('<3h', data[offset:offset+6])
        offset += 6
        gyro_raw = struct.unpack('<3h', data[offset:offset+6])
        offset += 6

        # Health: 3 floats = 12 bytes
        gyro_diff_dps, acc_angle_deg, vib_grms = struct.unpack(
            '<3f', data[offset:offset+12])
        offset += 12

        # EKF: 5 floats = 20 bytes
        theta_rad, thetaDot_rads, gyro_bias_rads, x_m, x_dot_mps = struct.unpack(
            '<5f', data[offset:offset+20])
        offset += 20

        # Wheels: 3 floats = 12 bytes
        wL_rads, wR_rads, v_mps = struct.unpack('<3f', data[offset:offset+12])
        offset += 12

        # PID: 9 floats = 36 bytes
        theta_ref_rad, e_theta_rad, P, I, D, u_common, u_turn, uL_cmd, uR_cmd = struct.unpack(
            '<9f', data[offset:offset+36])
        offset += 36

        # CRC: uint32 = 4 bytes
        crc32, = struct.unpack('<I', data[offset:offset+4])

        return cls(magic, version, flags, seq, t_us, active_imu,
                  acc_raw, gyro_raw,
                  gyro_diff_dps, acc_angle_deg, vib_grms,
                  theta_rad, thetaDot_rads, gyro_bias_rads, x_m, x_dot_mps,
                  wL_rads, wR_rads, v_mps,
                  theta_ref_rad, e_theta_rad, P, I, D, u_common, u_turn,
                  uL_cmd, uR_cmd,
                  crc32)

    def validate_crc(self, data: bytes) -> bool:
        """Validate record CRC (data should be full 160-byte record)"""
        computed_crc = zlib.crc32(data[:LOG_RECORD_MIN_SIZE-4]) & 0xFFFFFFFF
        return computed_crc == self.crc32

    def decode_flags(self) -> dict:
        """Decode status flags to readable names"""
        return {
            'accel_gated': bool(self.flags & LOGF_REC_ACCEL_GATED),
            'imu_fallback': bool(self.flags & LOGF_REC_IMU_FALLBACK),
            'left_saturated': bool(self.flags & LOGF_REC_UL_SAT),
            'right_saturated': bool(self.flags & LOGF_REC_UR_SAT),
            'fallen': bool(self.flags & LOGF_REC_FALLEN),
            'armed': bool(self.flags & LOGF_REC_ARMED),
        }


@dataclass
class LogDumpTrailer:
    """Dump file trailer (16 bytes)"""
    start_seq: int
    end_seq: int
    record_count: int
    dump_crc32: int

    @classmethod
    def from_bytes(cls, data: bytes) -> 'LogDumpTrailer':
        """Parse LogDumpTrailer from binary data"""
        if len(data) < 16:
            raise ValueError(f"LogDumpTrailer data too short: {len(data)} bytes")

        start_seq, end_seq, record_count, dump_crc32 = struct.unpack('<IIII', data[:16])
        return cls(start_seq, end_seq, record_count, dump_crc32)


class BlackboxParser:
    """Parser for blackbox dump files"""

    def __init__(self, filepath: Path):
        self.filepath = filepath
        self.meta: Optional[LogMeta] = None
        self.records: List[LogRecord] = []
        self.trailer: Optional[LogDumpTrailer] = None

    def parse(self) -> bool:
        """Parse dump file and validate structure"""
        print(f"Parsing: {self.filepath}")

        with open(self.filepath, 'rb') as f:
            data = f.read()

        if len(data) < LOG_META_SIZE + 16:
            print(f"Error: File too small ({len(data)} bytes)")
            return False

        # Parse metadata
        try:
            self.meta = LogMeta.from_bytes(data[:LOG_META_SIZE])
            if not self.meta.validate():
                print("Warning: Metadata CRC validation failed")
        except Exception as e:
            print(f"Error parsing metadata: {e}")
            return False

        record_size = LOG_RECORD_SIZE
        if self.meta and self.meta.record_size:
            record_size = self.meta.record_size
        if record_size < LOG_RECORD_MIN_SIZE:
            print(f"Warning: Record size ({record_size}) is smaller than parser minimum "
                  f"({LOG_RECORD_MIN_SIZE}); using {LOG_RECORD_SIZE} bytes")
            record_size = LOG_RECORD_SIZE

        record_start, aligned = self._find_record_start(
            data, LOG_META_SIZE, record_size, len(data) - 16)
        if not aligned:
            print("Warning: Record magic not found at expected alignment. "
                  "Dump may be empty or from a different firmware format.")

        # Parse records
        record_data_size = len(data) - record_start - 16
        expected_records = record_data_size // record_size

        print(f"Expected records: {expected_records}")

        for i in range(expected_records):
            record_offset = record_start + i * record_size
            record_data = data[record_offset:record_offset + record_size]

            if len(record_data) < LOG_RECORD_MIN_SIZE:
                break

            try:
                record = LogRecord.from_bytes(record_data)

                # Validate magic
                if record.magic != LOG_RECORD_MAGIC:
                    print(f"Warning: Record {i} has invalid magic: 0x{record.magic:04X}")
                    continue

                # Validate CRC (optional - can be slow)
                # if not record.validate_crc(record_data):
                #     print(f"Warning: Record {i} CRC failed")

                self.records.append(record)
            except Exception as e:
                print(f"Error parsing record {i}: {e}")
                continue

        # Parse trailer
        try:
            trailer_offset = len(data) - 16
            self.trailer = LogDumpTrailer.from_bytes(data[trailer_offset:])
        except Exception as e:
            print(f"Error parsing trailer: {e}")

        print(f"Successfully parsed {len(self.records)} records")

        # Validate counts
        if self.trailer and len(self.records) != self.trailer.record_count:
            print(f"Warning: Record count mismatch (parsed: {len(self.records)}, "
                  f"trailer: {self.trailer.record_count})")

        return len(self.records) > 0

    @staticmethod
    def _find_record_start(data: bytes, start: int, record_size: int, record_end: int):
        if start + 2 <= record_end and data[start:start + 2] == LOG_RECORD_MAGIC_BYTES:
            return start, True

        search_end = min(record_end - 2, start + max(record_size, MAX_RECORD_START_SEARCH))
        for candidate in range(start, search_end):
            if data[candidate:candidate + 2] != LOG_RECORD_MAGIC_BYTES:
                continue

            valid = True
            for i in range(1, 3):
                check = candidate + i * record_size
                if check + 2 > record_end:
                    break
                if data[check:check + 2] != LOG_RECORD_MAGIC_BYTES:
                    valid = False
                    break

            if valid:
                return candidate, True

        return start, False

    def print_info(self):
        """Print summary information"""
        if not self.meta:
            print("No metadata available")
            return

        print("\n=== Blackbox Dump Info ===")
        print(f"Version: {self.meta.version}")
        print(f"Record size: {self.meta.record_size} bytes")
        print(f"Log rate: {self.meta.rate_hz} Hz")
        print(f"Fields mask: 0x{self.meta.log_fields_mask:08X}")

        # Decode field mask
        fields = []
        if self.meta.log_fields_mask & LOGF_IMU_RAW:
            fields.append("IMU_RAW")
        if self.meta.log_fields_mask & LOGF_IMU2_HEALTH:
            fields.append("IMU2_HEALTH")
        if self.meta.log_fields_mask & LOGF_EKF:
            fields.append("EKF")
        if self.meta.log_fields_mask & LOGF_WHEELS:
            fields.append("WHEELS")
        if self.meta.log_fields_mask & LOGF_PID:
            fields.append("PID")
        print(f"Active fields: {', '.join(fields)}")

        print(f"\nBoot count: {self.meta.boot_count}")
        print(f"Last dump ID: {self.meta.last_dump_id}")

        if self.trailer:
            print(f"\n=== Dump Trailer ===")
            print(f"Sequence range: {self.trailer.start_seq} - {self.trailer.end_seq}")
            print(f"Record count: {self.trailer.record_count}")

        if self.records:
            print(f"\n=== Records ===")
            print(f"Total records: {len(self.records)}")
            first = self.records[0]
            last = self.records[-1]
            duration_ms = (last.t_us - first.t_us) / 1000.0
            print(f"Duration: {duration_ms:.1f} ms ({duration_ms/1000.0:.2f} seconds)")
            print(f"Timestamp range: {first.t_us} - {last.t_us} µs")
            print(f"Sequence range: {first.seq} - {last.seq}")

            # Count flags
            armed_count = sum(1 for r in self.records if r.flags & LOGF_REC_ARMED)
            fallen_count = sum(1 for r in self.records if r.flags & LOGF_REC_FALLEN)
            print(f"Armed records: {armed_count}")
            print(f"Fallen records: {fallen_count}")

    def export_csv(self, output_path: Path):
        """Export records to CSV"""
        if not self.records:
            print("No records to export")
            return

        import csv

        print(f"Exporting to CSV: {output_path}")

        with open(output_path, 'w', newline='') as f:
            writer = csv.writer(f)

            # Header
            header = [
                'seq', 't_us', 't_sec', 'active_imu', 'flags',
                'acc_x', 'acc_y', 'acc_z',
                'gyro_x', 'gyro_y', 'gyro_z',
                'gyro_diff_dps', 'acc_angle_deg', 'vib_grms',
                'theta_rad', 'theta_deg', 'thetaDot_rads', 'gyro_bias_rads',
                'x_m', 'x_dot_mps',
                'wL_rads', 'wR_rads', 'v_mps',
                'theta_ref_rad', 'e_theta_rad', 'P', 'I', 'D',
                'u_common', 'u_turn', 'uL_cmd', 'uR_cmd',
                'armed', 'fallen', 'saturated', 'accel_gated', 'imu_fallback'
            ]
            writer.writerow(header)

            # Data
            for rec in self.records:
                flags = rec.decode_flags()
                saturated = flags['left_saturated'] or flags['right_saturated']

                row = [
                    rec.seq, rec.t_us, rec.t_us / 1e6, rec.active_imu, rec.flags,
                    rec.acc_raw[0], rec.acc_raw[1], rec.acc_raw[2],
                    rec.gyro_raw[0], rec.gyro_raw[1], rec.gyro_raw[2],
                    rec.gyro_diff_dps, rec.acc_angle_deg, rec.vib_grms,
                    rec.theta_rad, rec.theta_rad * 57.2958, rec.thetaDot_rads, rec.gyro_bias_rads,
                    rec.x_m, rec.x_dot_mps,
                    rec.wL_rads, rec.wR_rads, rec.v_mps,
                    rec.theta_ref_rad, rec.e_theta_rad, rec.P, rec.I, rec.D,
                    rec.u_common, rec.u_turn, rec.uL_cmd, rec.uR_cmd,
                    int(flags['armed']), int(flags['fallen']), int(saturated),
                    int(flags['accel_gated']), int(flags['imu_fallback'])
                ]
                writer.writerow(row)

        print(f"Exported {len(self.records)} records")

    def plot(self):
        """Plot key signals"""
        if not self.records:
            print("No records to plot")
            return

        try:
            import matplotlib.pyplot as plt
            import numpy as np
        except ImportError:
            print("Error: matplotlib required for plotting")
            print("Install with: pip install matplotlib")
            return

        # Extract time series
        t = np.array([r.t_us / 1e6 for r in self.records])  # Convert to seconds
        t = t - t[0]  # Start at t=0

        theta = np.array([r.theta_rad * 57.2958 for r in self.records])  # Convert to degrees
        thetaDot = np.array([r.thetaDot_rads * 57.2958 for r in self.records])
        theta_ref = np.array([r.theta_ref_rad * 57.2958 for r in self.records])

        wL = np.array([r.wL_rads for r in self.records])
        wR = np.array([r.wR_rads for r in self.records])

        uL = np.array([r.uL_cmd for r in self.records])
        uR = np.array([r.uR_cmd for r in self.records])

        armed = np.array([bool(r.flags & LOGF_REC_ARMED) for r in self.records])

        # Create figure with subplots
        fig, axes = plt.subplots(4, 1, figsize=(12, 10), sharex=True)
        fig.suptitle(f'Blackbox Flight Data - {self.filepath.name}')

        # Plot 1: Pitch angle
        ax = axes[0]
        ax.plot(t, theta, 'b-', label='Pitch θ', linewidth=1)
        ax.plot(t, theta_ref, 'r--', label='Reference θ_ref', linewidth=1, alpha=0.7)
        ax.axhline(0, color='k', linestyle=':', linewidth=0.5)
        ax.fill_between(t, -90, 90, where=armed, alpha=0.2, color='green', label='Armed')
        ax.set_ylabel('Angle (deg)')
        ax.legend(loc='upper right')
        ax.grid(True, alpha=0.3)
        ax.set_title('Pitch Angle')

        # Plot 2: Pitch rate
        ax = axes[1]
        ax.plot(t, thetaDot, 'b-', label='θ̇', linewidth=1)
        ax.axhline(0, color='k', linestyle=':', linewidth=0.5)
        ax.set_ylabel('Rate (deg/s)')
        ax.legend(loc='upper right')
        ax.grid(True, alpha=0.3)
        ax.set_title('Pitch Rate')

        # Plot 3: Wheel velocities
        ax = axes[2]
        ax.plot(t, wL, 'b-', label='Left ωL', linewidth=1)
        ax.plot(t, wR, 'r-', label='Right ωR', linewidth=1)
        ax.axhline(0, color='k', linestyle=':', linewidth=0.5)
        ax.set_ylabel('Velocity (rad/s)')
        ax.legend(loc='upper right')
        ax.grid(True, alpha=0.3)
        ax.set_title('Wheel Velocities')

        # Plot 4: Motor commands
        ax = axes[3]
        ax.plot(t, uL, 'b-', label='Left uL', linewidth=1)
        ax.plot(t, uR, 'r-', label='Right uR', linewidth=1)
        ax.axhline(0, color='k', linestyle=':', linewidth=0.5)
        ax.set_ylabel('Command (Iq proxy)')
        ax.set_xlabel('Time (s)')
        ax.legend(loc='upper right')
        ax.grid(True, alpha=0.3)
        ax.set_title('Motor Commands')

        plt.tight_layout()
        plt.show()


def main():
    parser = argparse.ArgumentParser(
        description='Parse blackbox dump files from R2W robot',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s DUMP_0001.BIN --info
  %(prog)s DUMP_0001.BIN --csv output.csv
  %(prog)s DUMP_0001.BIN --plot
  %(prog)s DUMP_0001.BIN --csv output.csv --plot
        """)

    parser.add_argument('dumpfile', type=Path, help='Dump file (DUMP_*.BIN)')
    parser.add_argument('--csv', type=Path, help='Export to CSV file')
    parser.add_argument('--plot', action='store_true', help='Plot key signals')
    parser.add_argument('--info', action='store_true', help='Print dump info (default if no other action)')

    args = parser.parse_args()

    # Validate input file
    if not args.dumpfile.exists():
        print(f"Error: File not found: {args.dumpfile}")
        return 1

    # Parse dump file
    bb = BlackboxParser(args.dumpfile)
    if not bb.parse():
        print("Failed to parse dump file")
        return 1

    # Default action is --info if nothing else specified
    if not args.csv and not args.plot:
        args.info = True

    # Execute actions
    if args.info:
        bb.print_info()

    if args.csv:
        bb.export_csv(args.csv)

    if args.plot:
        bb.plot()

    return 0


if __name__ == '__main__':
    sys.exit(main())
